/* ///////////////////////////////////////////////////////////////////// */
/*! 
  \file  
  \brief Relativistic Blast Wave with Newtonian Gravity.

  Set the initial condition for a blast wave problem in RHD in the presence
  of a Newtonian gravitational field.
  Ambient density and pressure are constant everywhere and equal to 
  \c rho0 and \c p0. 
  While \c rho0 is an input parameter, \c p0=1.e-5.
  A large amount of energy is deposited in a small spherical volume,
  with radius \c R=0.5.
  The TAUB equation of state is applied, with initial polytropic index
  \c gamma=4./3. .
  The Newtonian gravitational field is introduced by enabling the
  BODY_FORCE flag in definitions.h and setting it to VECTOR.	
  The field is assumed to be isotropic and generated by a point mass located
  at the origin. 
  The value of the point mass \c MASS (in unit of solar masses) is an
  input parameter.

  The input parameters read from pluto.ini are labeled as:
  - <tt>g_inputParam[ENRG0]</tt>: initial energy of the blast wave
    (\e not energy density);
  - <tt>g_inputParam[DNST0]</tt>: initial constant density;
  - <tt>g_inputParam[MASS]</tt>: central point mass.

  The available configurations refer to:
  -# Spherical (1D)   (conf. #1)
  -# Cylindrical (2D) (conf. #2)
  -# Cartesian (3D)   (conf. #3)
  -# Spehrical (3D)   (conf. #4)	
  
  - Configuration #4 is computed by setting the \tt polaraxis boundary conditions 
    at X2-beg and X2-end.
    These b.c. are used in conjuction with the ring average technique 
    to remove the CFL restriction 
    imposed by the clustering of cells in the azimuthal direction near the axis. 
    RING_AVERAGE is set equal to 8 in definitions.h (see Userguide and ref. below).

  \author A. Pavan (andrea.pavan.20@phd.unipd.it)
  \date   May 04, 2020  

  \b References
     - B. Zhang, K. A. Sorathia, J. G. Lyon, V. G. Merkin, and M. Wiltberger, "Conservative 
       averaging-reconstruction techniques (Ring Average) for 3-D finite-volume MHD solvers
       with axis singularity", Journal of Computational Physics 376 (2019), pp. 276â€“294.
*/
/* ///////////////////////////////////////////////////////////////////// */
#include "pluto.h"

/* ********************************************************************* */
void Init (double *us, double x1, double x2, double x3)
/*
 *
 *
 *
 *********************************************************************** */
{
  double gamma, R, vol, r;

/* ---------------------------------------
     compute region volume 
   --------------------------------------- */

  R   = 0.5;
  vol = 4.0/3.0*CONST_PI*R*R*R;

  #if (GEOMETRY == SPHERICAL && DIMENSIONS == 1) || (GEOMETRY == SPHERICAL && DIMENSIONS == 3)
   
  r = x1*x1;

  #elif ((GEOMETRY == CYLINDRICAL) || (GEOMETRY == CARTESIAN)) && DIMENSIONS == 2

  r = x1*x1 + x2*x2;

  #elif (GEOMETRY == CARTESIAN && DIMENSIONS == 3)

  r = x1*x1 + x2*x2 + x3*x3; 
 
  #else
  print ("! Init: geometrical configuration not allowed\n");
  QUIT_PLUTO(1);
  #endif

  r = sqrt(r);

  us[RHO] = g_inputParam[DNST0];
  us[VX1] = 0.0;
  us[VX2] = 0.0;
  us[VX3] = 0.0;

  gamma = 4./3.;

  if (r <= R)   us[PRS] = (gamma - 1.0)*g_inputParam[ENRG0]/vol;
  else          us[PRS] = 1.e-5;
/*
double pin = (gamma - 1.0)*g_inputParam[ENRG0]/vol;
double pout = 1.e-5;
double arg = pow(r/R,2.0);
double delta = 1.0/50.0;
double prof = 0.5*(1.0 - tanh( (r-R)/delta));
us[PRS] = pin*prof + pout*(1.0 - prof);
*/

}

/* ********************************************************************* */
void InitDomain (Data *d, Grid *grid)
/* 
 *
 *
 *********************************************************************** */
{
}

/* ********************************************************************* */
void Analysis (const Data *d, Grid *grid)
/* 
 *
 *
 *********************************************************************** */
{

}

/* ********************************************************************* */
void UserDefBoundary (const Data *d, RBox *box, int side, Grid *grid) 
/*
 *
 *
 *********************************************************************** */
{ 

}

/* ********************************************************************* */
void BodyForceVector (double *v, double *g, double x1, double x2, double x3)
{
/* 
 *
 *
 *********************************************************************** */

 double r, r2, r3, gs;
 double g0 = (UNIT_LENGTH/(UNIT_VELOCITY*UNIT_VELOCITY));
 #if (GEOMETRY == SPHERICAL) && ((DIMENSIONS == 1) || (DIMENSIONS == 3))

  r2 = x1*x1;

 #elif ((GEOMETRY == CYLINDRICAL) || (GEOMETRY == CARTESIAN)) && DIMENSIONS == 2

  r2 = x1*x1 + x2*x2;

 #elif (GEOMETRY == CARTESIAN && DIMENSIONS == 3)

  r2 = x1*x1 + x2*x2 + x3*x3;

 #else
  print ("! Init: geometrical configuration not allowed\n");
  QUIT_PLUTO(1);
 #endif

  r2 = r2*UNIT_LENGTH*UNIT_LENGTH;
  r  = sqrt(r2);
  r3 = r2*r;
  gs = -(CONST_G*g_inputParam[MASS]*CONST_Msun/r3)*g0;
 
 #if (GEOMETRY == SPHERICAL)
  
  g[IDIR] = gs*x1*UNIT_LENGTH;
  g[JDIR] = 0.0;
  g[KDIR] = 0.0;

 #elif (GEOMETRY == CYLINDRICAL)

  g[IDIR] = gs*x1*UNIT_LENGTH;
  g[JDIR] = gs*x2*UNIT_LENGTH;
  g[KDIR] = 0.0;

 #elif (GEOMETRY == CARTESIAN)

  g[IDIR] = gs*x1*UNIT_LENGTH;
  g[JDIR] = gs*x2*UNIT_LENGTH;
  g[KDIR] = gs*x3*UNIT_LENGTH;

 #endif

}

