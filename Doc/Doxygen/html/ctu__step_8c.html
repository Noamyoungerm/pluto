<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PLUTO: /Users/mignone/PLUTO/Src/Time_Stepping/ctu_step.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PLUTO
   &#160;<span id="projectnumber">4.4-patch2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_413f4e031a85da0d68269c6fd2f76e1c.html">Src</a></li><li class="navelem"><a class="el" href="dir_8239a6a3a28c8d42ffb2efb4ffd69d6c.html">Time_Stepping</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ctu_step.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Advance equations using Corner Transport Upwind (CTU).  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="pluto_8h_source.html">pluto.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a99d49b302febd10e96ff7e81829aa7b7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ctu__step_8c.html#a99d49b302febd10e96ff7e81829aa7b7">CTU_CT_Source</a> (const <a class="el" href="struct_sweep.html">Sweep</a> *, int, int, double *, <a class="el" href="struct_grid.html">Grid</a> *)</td></tr>
<tr class="separator:a99d49b302febd10e96ff7e81829aa7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777eae92b891ab436026cc38c99d07e1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ctu__step_8c.html#a777eae92b891ab436026cc38c99d07e1">AdvanceStep</a> (<a class="el" href="struct_data.html">Data</a> *data, <a class="el" href="structtime_step.html">timeStep</a> *Dts, <a class="el" href="struct_grid.html">Grid</a> *grid)</td></tr>
<tr class="separator:a777eae92b891ab436026cc38c99d07e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implement the dimensionally unsplit, Corner Transport Upwind method (CTU) of Colella: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ U^{n+1} = U^{n} + \Delta t\sum_d\Big({\cal L}^{n+\HALF}_{\rm H,d} + {\cal L}^{n+\HALF}_{\rm P,d}\Big) \]" src="form_344.png"/>
</p>
<p> where <img class="formulaInl" alt="${\cal L}^{n+\HALF}$" src="form_345.png"/> is the right hand side at the half time step corresponding to the hyperbolic (<code>H</code>) and parabolic (<code>P</code>) part. The right hand side is constructed using the flux obtained from the solution of Riemann problems between corner coupled states. In absence of diffusion term we use: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ U^{n+\HALF}_{i,\pm} = U^*_{i,\pm} + \frac{\Delta t}{2}\sum_{d \neq x}{\cal L}^*_{\rm H,d} = U^*_{i,\pm} - \frac{\Delta t}{2}{\cal L}^*_{\rm H,x} + \frac{\Delta t}{2}\sum_d {\cal L}^*_{\rm H,d} \]" src="form_346.png"/>
</p>
<p> The second equation form is preferred for computational efficiency since the <img class="formulaInl" alt="${\cal L}^*$" src="form_347.png"/> are obtained during 1-D sweeps by solving Riemann problems between normal states: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ V^{*}_{i,\pm} = V^n_{i,\pm} + \frac{\Delta t}{2}\pd{V}{t} + \frac{\Delta t}{2}S_i \]" src="form_348.png"/>
</p>
<p>In presence of explicit diffusion fluxes, the predictor step is modified by computing the RHS from 1st order states at t^n: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ U^{n+\HALF}_{i,\pm} = U^*_{i,\pm} + \frac{\Delta t}{2}\left( \sum_{d\neq x}{\cal L}^n_{\rm H,d} + \sum_{d}{\cal L}^n_{\rm P,d}\right) = U^*_{i,\pm} - \frac{\Delta t}{2}{\cal L}^n_{\rm H,x} + \frac{\Delta t}{2}\sum_d\left( {\cal L}^n_{\rm H,d} + {\cal L}^n_{\rm P,d}\right) \]" src="form_349.png"/>
</p>
<p> This allows to obtain space and time centered states in one row of boundary zones required during the corrector step.</p>
<p>The update is done through a normal (predictor) and corrector step:</p>
<p>1) <b> Predictor step </b>: Construct <img class="formulaInl" alt="$ U^*_{i,\pm} - \frac{\Delta t}{2}{\cal L}^*_{\rm H,x} $" src="form_350.png"/> and also the full right hand side <img class="formulaInl" alt="${\cal L}^*_{\rm H} = \sum_d{\cal L}^*_{\rm H,d}$" src="form_351.png"/> and similarly for the <code>y</code> and <code>z</code> directions. Note that <img class="formulaInl" alt="$U^*_{i,\pm}$" src="form_352.png"/> are defined on a larger stencil than <img class="formulaInl" alt="${\cal L}^*_{\rm H}$" src="form_353.png"/> and therefore we need to zero the rhs where it is not defined. Schematically, in a 2-D domain the total right hand side <img class="formulaInl" alt="${\cal L}^*$" src="form_347.png"/> is built by collecting contributions coming from 1D sweeps:</p>
<pre class="fragment">  0|     Lx      |0                  0|     Lx      |0
  -+-------------+                   -+-------------+-
   |             |                    |             |
   |             |                    |             |
  0|     Lx      |0       --&gt;       Ly|    Lx+Ly    |Ly  
   |             |                    |             |
   |             |                    |             |
  -+-------------+-                  -+-------------+-
  0|     Lx      |0                  0|     Lx      |0

      (X sweep)                          (Y sweep)
</pre><p>Normal states (U^*=Ux,Uy) are instead computed on the following box:</p>
<pre class="fragment"> Ux|    Ux-Lx    |Ux                Uy|      Uy     |Uy
  -+-------------+-                  -+-------------+-
   |             |                    |             |
   |             |                    |             |   
 Ux|    Ux-Lx    |Ux      --&gt;    Uy-Ly|    Uy-Ly    |Uy-Ly  
   |             |                    |             | 
   |             |                    |             | 
  -+-------------+-                  -+-------------+-
 Ux|    Ux-Lx    |Ux                Uy|      Uy     |Uy   

      (X sweep)                          (Y sweep)
</pre><p>Beware that with staggered MHD or explicit parabolic terms the schematic box is one zone larger than the actual computational domain.</p>
<p>2) <b> Corrector step </b>: Compute corner coupled states by adding the full right hand side </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ U^{n+\HALF}_{i,\pm} = \Big(U^*_{i,\pm} - \frac{\Delta t}{2}{\cal L}^*_{\rm H,x}\Big) + \frac{\Delta t}{2}\sum_d {\cal L}^*_{\rm H,d} \]" src="form_354.png"/>
</p>
<p> where the term in round bracket is available from the Predictor step. Thenand solve Riemann problems. Construct right hand side <img class="formulaInl" alt="${\cal L}^{n+\HALF}$" src="form_345.png"/> and update conserved variables.</p>
<p>This integrator performs an integration in the ghost boundary zones, in order to recover appropriate information to build the transverse predictors. If constrained transport is enabled then, in summary, normal and transverse indices are handled as follows</p>
<pre class="fragment">                      RK        CTU
                 +-------------------------------------------
  Transverse++   |    YES       YES
                 |
  Normal++       |    NO        YES, at predictor step
</pre><p>Predictor step (g_intStage = 1) in CTU requires extra transverse loop to obtain transverse predictor in any case. Also, with CTU+CT, one needs to expand the grid of one zone in the <em>normal</em> direction as well. This allows to computed fully corner coupled sweeps in the boundary to get electric field components during the constrained transport algorithm.</p>
<p><b>References</b> </p><ul>
<li>"The PLUTO Code for Adaptive Mesh Computations in Astrophysical Fluid
      Dynamics" <br />
 Mignone et al., ApJS (2012), 198:7</li>
<li>"A second-order unsplit Godunov scheme for cell-centered MHD:
      the CTU-GLM scheme" <br />
 Mignone &amp; Tzeferacos JCP (2010), 229, 2117</li>
<li>"An unsplit Godunov method for ideal MHD via constrained transport" <br />
 Gardiner &amp; Stone, JCP (2005), 205, 509</li>
</ul>
<dl class="section author"><dt>Authors</dt><dd>A. Mignone (<a href="#" onclick="location.href='mai'+'lto:'+'mig'+'no'+'ne@'+'to'+'.in'+'fn'+'.it'; return false;">migno<span style="display: none;">.nosp@m.</span>ne@t<span style="display: none;">.nosp@m.</span>o.inf<span style="display: none;">.nosp@m.</span>n.it</a>) </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Sep 14, 2019 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a777eae92b891ab436026cc38c99d07e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a777eae92b891ab436026cc38c99d07e1">&#9670;&nbsp;</a></span>AdvanceStep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AdvanceStep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_data.html">Data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtime_step.html">timeStep</a> *&#160;</td>
          <td class="paramname"><em>Dts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_grid.html">Grid</a> *&#160;</td>
          <td class="paramname"><em>grid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Advance equations using the corner transport upwind method (CTU)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d</td><td>pointer to <a class="el" href="struct_data.html">Data</a> structure </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Dts</td><td>pointer to time step structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">grid</td><td>pointer to <a class="el" href="struct_grid.html">Grid</a> structur </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99d49b302febd10e96ff7e81829aa7b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99d49b302febd10e96ff7e81829aa7b7">&#9670;&nbsp;</a></span>CTU_CT_Source()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CTU_CT_Source </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sweep.html">Sweep</a> *&#160;</td>
          <td class="paramname"><em>sweep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dtdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_grid.html">Grid</a> *&#160;</td>
          <td class="paramname"><em>grid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add source terms to conservative left and right states obtained from the primitive form of the equations. The source terms are:</p>
<ul>
<li>m += dt/2 * B * dbx/dx</li>
<li>Bt += dt/2 * vt * dbx/dx (t = transverse component)</li>
<li>E += dt/2 * v*B * dbx/dx</li>
</ul>
<p>These terms are NOT accounted for when the primitive form of the equations is used (see Gardiner &amp; Stone JCP (2005), Crockett et al. JCP(2005)). This is true for both the Charactheristic Tracing AND the primitive Hancock scheme when the constrained transport is used, since the resulting system is 7x7. To better understand this, you can consider the stationary solution rho = p = 1, v = 0 and Bx = x, By = -y. If these terms were not included the code would generate spurious velocities. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Jun 26 2021 13:23:58 for PLUTO by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
