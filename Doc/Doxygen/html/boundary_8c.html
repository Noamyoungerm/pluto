<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>PLUTO: /Users/mignone/PLUTO/Src/boundary.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PLUTO
   &#160;<span id="projectnumber">4.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_413f4e031a85da0d68269c6fd2f76e1c.html">Src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">boundary.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Set boundary conditions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="pluto_8h_source.html">pluto.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa4ac8e2a2c5749634c201e8c8701d248"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="boundary_8c.html#aa4ac8e2a2c5749634c201e8c8701d248">FlipSign</a> (int, int, int *)</td></tr>
<tr class="separator:aa4ac8e2a2c5749634c201e8c8701d248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a737d3862f4cf347b9f2216b6310edde7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="boundary_8c.html#a737d3862f4cf347b9f2216b6310edde7">Boundary</a> (const <a class="el" href="struct_data.html">Data</a> *d, int idim, <a class="el" href="struct_grid.html">Grid</a> *grid)</td></tr>
<tr class="separator:a737d3862f4cf347b9f2216b6310edde7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d460347652e7d9f5495ea10d2bae65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="boundary_8c.html#a40d460347652e7d9f5495ea10d2bae65">OutflowBoundary</a> (double ***q, <a class="el" href="struct_r_box.html">RBox</a> *box, int side)</td></tr>
<tr class="separator:a40d460347652e7d9f5495ea10d2bae65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6280cd6ff9db6d2e28fc8503ae7fdea8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="boundary_8c.html#a6280cd6ff9db6d2e28fc8503ae7fdea8">PeriodicBoundary</a> (double ***q, <a class="el" href="struct_r_box.html">RBox</a> *box, int side)</td></tr>
<tr class="separator:a6280cd6ff9db6d2e28fc8503ae7fdea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f86b18467f2d476956cb0e773d5c2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="boundary_8c.html#af1f86b18467f2d476956cb0e773d5c2a">ReflectiveBoundary</a> (double ***q, int s, int stag, <a class="el" href="struct_r_box.html">RBox</a> *box, int side)</td></tr>
<tr class="separator:af1f86b18467f2d476956cb0e773d5c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80dffcc90bfaed8ac6a9a095cffb1a1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="boundary_8c.html#a80dffcc90bfaed8ac6a9a095cffb1a1f">PolarAxisBoundary</a> (const <a class="el" href="struct_data.html">Data</a> *d, <a class="el" href="struct_r_box.html">RBox</a> *box, int side)</td></tr>
<tr class="separator:a80dffcc90bfaed8ac6a9a095cffb1a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="boundary_8c.html#a737d3862f4cf347b9f2216b6310edde7">Boundary()</a> function sets both internal and physical boundary conditions on one or more sides of the computational domain. It is used to fill ghost zones of both cell-centered and face-centered data arrays.<br />
The type of boundary conditions at the leftmost or rightmost side of a given grid is specified by the integers <code> grid.lbound[dir] </code> or <code> grid.rbound[dir] </code>, respectively. When this value is different from zero, the local processor borders the physical boundary and the admissible values for <code>lbound</code> or <code>rbound</code> are OUTFLOW, REFLECTIVE, AXISYMMETRIC, EQTSYMMETRIC, PERIODIC, SHEARING or USERDEF. Conversely, when this value is zero (internal boundary), two neighboring processors that share the same side need to fill ghost zones by exchanging data values. This step is done here only for parallel computations on static grids.</p>
<p>Predefined physical boundary conditions are handled by the following functions:</p>
<ul>
<li><a class="el" href="boundary_8c.html#a40d460347652e7d9f5495ea10d2bae65">OutflowBoundary()</a></li>
<li><a class="el" href="boundary_8c.html#af1f86b18467f2d476956cb0e773d5c2a">ReflectiveBoundary()</a></li>
<li><a class="el" href="boundary_8c.html#a6280cd6ff9db6d2e28fc8503ae7fdea8">PeriodicBoundary()</a></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>For staggered mesh+periodic b.c, the leftmost value of <em>each</em> processor overwritten with a value NX1 zones to the right:</dd></dl>
<pre class="fragment">--&gt;Before:

   proc #0     proc #1     proc #2     proc #3
  |.......|   |.......|   |.......|   |.......|
  A       B   C       D   E       F   G       H

--&gt; PeriodicBoundary()
--&gt; After:

   proc #0     proc #1     proc #2     proc #3
  |.......|   |.......|   |.......|   |.......|
  H       B   B       D   D       F   F       H
</pre><dl class="section author"><dt>Author</dt><dd>A. Mignone (<a href="#" onclick="location.href='mai'+'lto:'+'mig'+'no'+'ne@'+'to'+'.in'+'fn'+'.it'; return false;">migno<span style="display: none;">.nosp@m.</span>ne@t<span style="display: none;">.nosp@m.</span>o.inf<span style="display: none;">.nosp@m.</span>n.it</a>) </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Sep 14, 2020 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a737d3862f4cf347b9f2216b6310edde7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_data.html">Data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_grid.html">Grid</a> *&#160;</td>
          <td class="paramname"><em>grid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set boundary conditions on one or more sides of the computational domain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d</td><td>pointer to PLUTO <a class="el" href="struct_data.html">Data</a> structure containing the solution array (including centered and staggered fields) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idim</td><td>specifies on which side(s) of the computational domain boundary conditions must be set. Possible values are<ul>
<li>idim = IDIR first dimension (x1)</li>
<li>idim = JDIR second dimenson (x2)</li>
<li>idim = KDIR third dimension (x3)</li>
<li>idim = ALL_DIR all dimensions</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">grid</td><td>pointer to grid structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa4ac8e2a2c5749634c201e8c8701d248"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FlipSign </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>vsign</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reverse the sign of vector components with respect to axis side. Depending on type, one needs to symmetrize or anti-symmetrize:</p>
<ul>
<li>REFLECTIVE: <br />
 o Vn -&gt; -Vn, Bn -&gt; -Bn, En -&gt; En <br />
 o Vp -&gt; Vp, Bp -&gt; Bp, Ep -&gt; -Ep <br />
 o Vt -&gt; Vt, Bt -&gt; Bt, Et -&gt; -Et</li>
<li>AXISYMMETRIC: <br />
 o Vn -&gt; -Vn, Bn -&gt; -Bn, En -&gt; -En <br />
 o Vp -&gt; Vp, Bp -&gt; Bp, Ep -&gt; Ep <br />
 o Vt -&gt; -Vt, Bt -&gt; -Bt, Et -&gt; -Et</li>
<li>EQTSYMMETRIC: <br />
 o Vn -&gt; -Vn, Bn -&gt; Bn, En -&gt; -En <br />
 o Vp -&gt; Vp, Bp -&gt; -Bp, Ep -&gt; Ep <br />
 o Vt -&gt; Vt, Bt -&gt; -Bt, Et -&gt; Et</li>
</ul>
<p>where (n) is the normal components, (p) and (t) are the transverse (or poloidal and toroidal for cylindrical and spherical coordinates) components.</p>
<p>If the radiation module is used, the transformation law for the radiation flux is the same as for the velocities.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">side</td><td>boundary side </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>boundary condition type </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vsign</td><td>an array of values (+1 or -1) giving the sign </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a40d460347652e7d9f5495ea10d2bae65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OutflowBoundary </td>
          <td>(</td>
          <td class="paramtype">double ***&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_r_box.html">RBox</a> *&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>side</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Impose zero-gradient boundary conditions on 'q' on the boundary side specified by 'side'. The input array 'q' must not represent the normal component of a staggered magnetic fied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">q</td><td>a 3D array requiring ghost zone filling </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">box</td><td>pointer to a <a class="el" href="struct_r_box.html">RBox</a> structure defining the extent of the boundary region </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">side</td><td>the side of the computational domain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6280cd6ff9db6d2e28fc8503ae7fdea8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PeriodicBoundary </td>
          <td>(</td>
          <td class="paramtype">double ***&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_r_box.html">RBox</a> *&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>side</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implements periodic boundary conditions in serial mode or when one processor only handle the periodic direction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">q</td><td>a 3D array requiring ghost zone filling </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">box</td><td>pointer to a <a class="el" href="struct_r_box.html">RBox</a> structure defining the extent of the boundary region </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">side</td><td>the side of the computational domain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a80dffcc90bfaed8ac6a9a095cffb1a1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PolarAxisBoundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_data.html">Data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_r_box.html">RBox</a> *&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>side</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Boundary conditions on singular axis. </p>

</div>
</div>
<a class="anchor" id="af1f86b18467f2d476956cb0e773d5c2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ReflectiveBoundary </td>
          <td>(</td>
          <td class="paramtype">double ***&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_r_box.html">RBox</a> *&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>side</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make symmetric (s = 1) or anti-symmetric (s = -1) profiles with respect to the boundary plane specified by box-&gt;side. The sign is set by the <a class="el" href="boundary_8c.html#aa4ac8e2a2c5749634c201e8c8701d248">FlipSign()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">q</td><td>a 3D array requiring ghost zone filling </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>an integer taking only the values +1 (symmetric profile) or -1 (antisymmetric profile) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stag</td><td>an integer taking the values 0 (centered with respect to the boundary) or 1 (staggered with respect to the boundary). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">box</td><td>pointer to a <a class="el" href="struct_r_box.html">RBox</a> structure defining the extent of the boundary region </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">side</td><td>the side of the computational domain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 14 2020 21:28:57 for PLUTO by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
